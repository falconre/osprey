// This script takes the path to a binary, and the name of a function, and
// prints out a graphviz dot graph of that function in Falcon IL.


// Some standard boilerplate stuff for gluon
let io = import! "std/io.glu"
let option = import! "std/types.glu"
let function = import! "std/function.glu"
let { Option } = option
let { (|>) } = function

let string = import! "std/string.glu"
let { (==) } = string.eq
let (++) = string_prim.append

let unwrap option = 
    match option with
    | Some x -> x
    | None -> error "unwrapped option with value None"


// Import the falcon library
let falcon = import! "lib/falcon.glu"
let { il, loader } = falcon


// Arguments to our script
let filename = falcon.env "FILENAME" |> unwrap
let function_name = falcon.env "FUNCTION_NAME" |> unwrap


// Load the elf
let elf = loader.elf.from_file filename


// Calls loader::Loader::function_entries() and walks the resulting entries until
// an entry with desired name is found, and returns that
let find_function elf function_name =
    let find functions i name =
        if i == (array.len functions) then
            None
        else
            let function_entry = array.index functions i
            match loader.function_entry.name function_entry with
            | Some entry_name ->
                if entry_name == name then
                    Some function_entry
                else
                    find functions (i + 1) name
            | None -> find functions (i + 1) name
    find (loader.elf.function_entries elf) 0 function_name


// If we found our target function, return the dot graph of the CFG.
let output =
    match find_function elf function_name with
    | None -> "Could not find " ++ function_name
    | Some function_entry -> 
        let address = loader.function_entry.address function_entry
        let function = loader.elf.function elf address
        let cfg = il.function.control_flow_graph function
        il.control_flow_graph.dot_graph cfg

io.println output