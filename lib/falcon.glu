let io = import! "std/io.glu"

let prelude = import! "std/prelude.glu"
let { (|>) } = prelude

let types = import! "std/types.glu"
let { Option } = types

let test = import! "std/test.glu"
let { assert } = test

let string = import! "std/string.glu"
let { (==) } = string.eq

type Expression = | Scalar   s
                  | Constant c
                  | Add      l r
                  | Sub      l r
                  | Mul      l r
                  | Divu     l r
                  | Modu     l r
                  | Divs     l r
                  | Mods     l r
                  | And      l r
                  | Or       l r
                  | Xor      l r
                  | Shl      l r
                  | Shr      l r
                  | Cmpeq    l r
                  | Cmpneq   l r
                  | Cmplts   l r
                  | Cmpltu   l r
                  | Zext     bits src
                  | Sext     bits src
                  | Trun     bits src

type Operation = | Assign dst src
                 | Store  dst index src
                 | Load   dst index src
                 | Brc    target condition
                 | Phi    dst src
                 | Raise  expr


let expression_match expression =
    let get_lhs = falcon_prim.expression_get_lhs
    let get_rhs = falcon_prim.expression_get_rhs
    let get_bits = falcon_prim.expression_get_bits

    let typ = falcon_prim.expression_type expression

    if typ == "scalar" then
        Scalar (falcon_prim.expression_get_scalar expression)
    else if typ == "constant" then
        Constant (falcon_prim.expression_get_constant expression)
    else if typ == "add" then
        Add (get_lhs expression) (get_rhs expression)
    else if typ == "sub" then
        Sub (get_lhs expression) (get_rhs expression)
    else if typ == "mul" then
        Mul (get_lhs expression) (get_rhs expression)
    else if typ == "divu" then
        Divu (get_lhs expression) (get_rhs expression)
    else if typ == "modu" then
        Modu (get_lhs expression) (get_rhs expression)
    else if typ == "divs" then
        Divs (get_lhs expression) (get_rhs expression)
    else if typ == "mods" then
        Mods (get_lhs expression) (get_rhs expression)
    else if typ == "and" then
        And (get_lhs expression) (get_rhs expression)
    else if typ == "or" then
        Or (get_lhs expression) (get_rhs expression)
    else if typ == "xor" then
        Xor (get_lhs expression) (get_rhs expression)
    else if typ == "shl" then
        Shl (get_lhs expression) (get_rhs expression)
    else if typ == "shr" then
        Shr (get_lhs expression) (get_rhs expression)
    else if typ == "cmpeq" then
        Cmpeq (get_lhs expression) (get_rhs expression)
    else if typ == "cmpneq" then
        Cmpneq (get_lhs expression) (get_rhs expression)
    else if typ == "cmplts" then
        Cmplts (get_lhs expression) (get_rhs expression)
    else if typ == "cmpltu" then
        Cmpltu (get_lhs expression) (get_rhs expression)
    else if typ == "zext" then
        Zext (get_bits expression) (get_rhs expression)
    else if typ == "sext" then
        Sext (get_bits expression) (get_rhs expression)
    else
        Trun (get_bits expression) (get_rhs expression)


let operation_match operation =
    let typ = falcon_prim.operation_type operation

    if typ == "assign" then
        Assign (falcon_prim.operation_assign_dst operation) (falcon_prim.operation_assign_src operation)
    else if typ == "store" then
        Store (falcon_prim.operation_store_dst operation) (falcon_prim.operation_store_index operation) (falcon_prim.operation_store_src operation)
    else if typ == "load" then
        Load (falcon_prim.operation_load_dst operation) (falcon_prim.operation_load_index operation) (falcon_prim.operation_load_src operation)
    else if typ == "brc" then
        Brc (falcon_prim.operation_brc_target operation) (falcon_prim.operation_brc_condition operation)
    else if typ == "raise" then
        Raise (falcon_prim.operation_raise_expr operation)
    else
        Phi 0 0


let edge_condition edge =
    if falcon_prim.edge_has_condition edge then
        Some (falcon_prim.edge_condition edge)
    else
        None


{
    il = {
        block = {
            index = falcon_prim.block_index,
            instructions = falcon_prim.block_instructions,
            assign = falcon_prim.block_assign,
            store = falcon_prim.block_store,
            load = falcon_prim.block_load,
            brc = falcon_prim.block_brc,
            raise = falcon_prim.block_raise,
            str = falcon_prim.block_str
        },

        control_flow_graph = {
            blocks = falcon_prim.control_flow_graph_blocks,
            dot_graph = falcon_prim.control_flow_graph_dot_graph,
            edges = falcon_prim.control_flow_graph_edges,
            str = falcon_prim.control_flow_graph_str
        },

        constant = {
            new = falcon_prim.constant_new,
            value = falcon_prim.constant_value,
            bits = falcon_prim.constant_bits,
            str = falcon_prim.constant_str
        },

        edge = {
            condition = falcon_prim.edge_condition,
            head = falcon_prim.edge_head,
            tail = falcon_prim.edge_tail,
            str = falcon_prim.edge_str
        },

        expression = {
            scalar = falcon_prim.expression_scalar,
            constant = falcon_prim.expression_constant,
            add = falcon_prim.expression_add,
            sub = falcon_prim.expression_sub,
            mul = falcon_prim.expression_mul,
            divu = falcon_prim.expression_divu,
            modu = falcon_prim.expression_modu,
            divs = falcon_prim.expression_divs,
            mods = falcon_prim.expression_mods,
            and_ = falcon_prim.expression_and,
            or = falcon_prim.expression_or,
            xor = falcon_prim.expression_xor,
            shl = falcon_prim.expression_shl,
            shr = falcon_prim.expression_shr,
            cmpeq = falcon_prim.expression_cmpeq,
            cmpneq = falcon_prim.expression_cmpneq,
            cmplts = falcon_prim.expression_cmplts,
            cmpltu = falcon_prim.expression_cmpltu,
            zext = falcon_prim.expression_zext,
            sext = falcon_prim.expression_sext,
            trun = falcon_prim.expression_trun,
            match_ = expression_match,
            str = falcon_prim.expression_str,
        },

        function = {
            control_flow_graph = falcon_prim.function_control_flow_graph
        },

        instruction = {
            index = falcon_prim.instruction_index,
            operation = falcon_prim.instruction_operation,
            str = falcon_prim.instruction_str
        },

        operation = {
            assign = falcon_prim.operation_assign,
            store = falcon_prim.operation_store,
            load = falcon_prim.operation_load,
            brc = falcon_prim.operation_brc,
            raise = falcon_prim.operation_raise,
            match_ = operation_match,
            str = falcon_prim.operation_str
        },

        scalar = {
            new = falcon_prim.scalar_new,
            name = falcon_prim.scalar_name,
            bits = falcon_prim.scalar_bits,
            str = falcon_prim.scalar_str
        }
    },

    loader = {
        elf = {
            base_address = falcon_prim.elf_base_address,
            from_file = falcon_prim.elf_from_file,
            function_entries = falcon_prim.elf_function_entries,
            function = falcon_prim.elf_function,
            memory = falcon_prim.elf_memory
        },

        function_entry = {
            name = falcon_prim.function_entry_name,
            address = falcon_prim.function_entry_address,
            str = falcon_prim.function_entry_str
        }
    },

    types = {
        Operation,
        Expression
    }
}